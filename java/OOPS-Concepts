# üß† Java OOPs & Automation Framework ‚Äì Study Notes

---

## ‚úÖ 1. Interface ‚Äì What & Why

- An **interface** defines **what** should be done, not **how**.
- Only method signatures ‚Äî no method body (implementation).
- Used to build **flexible and reusable automation frameworks**.

### üîπ Example:
```java
public interface Browser {
    void openBrowser();
    void closeBrowser();
}
```

```java
public class ChromeBrowser implements Browser {
    WebDriver driver;

    public void openBrowser() {
        driver = new ChromeDriver();
    }

    public void closeBrowser() {
        driver.quit();
    }
}
```

‚úÖ You can switch between browsers easily:
```java
Browser browser = new ChromeBrowser();  // Later: new FirefoxBrowser();
```

---

## ‚úÖ 2. Why WebDriver is an Interface

- `WebDriver` is an interface in Selenium that defines common browser actions.
- It allows us to work with multiple browsers (Chrome, Firefox, etc.) using the same code.

```java
WebDriver driver = new ChromeDriver(); // or FirefoxDriver, EdgeDriver, etc.
```

‚úî Benefit: Browser-independent, reusable automation code.

---

## ‚úÖ 3. Polymorphism ‚Äì Real Use in Automation

- **Polymorphism** = ‚ÄúOne interface, many forms (objects)‚Äù.
- You can use an interface type (`Browser`) to hold objects of different classes (`ChromeBrowser`, `FirefoxBrowser`).

```java
Browser browser = new ChromeBrowser();
browser.openBrowser();
```

üîÅ Later:
```java
browser = new FirefoxBrowser();  // Without changing test logic
```

---

## ‚úÖ 4. Abstract Class ‚Äì What & Why

- An **abstract class** is a partially complete class.
- It can have:
  - **Concrete methods** (with code)
  - **Abstract methods** (without code)

### üîπ Example:
```java
public abstract class BaseTest {
    WebDriver driver;

    public void openUrl(String url) {
        driver.get(url);
    }

    public abstract void setup(); // must be implemented by child
}
```

```java
public class ChromeTest extends BaseTest {
    public void setup() {
        driver = new ChromeDriver();
    }
}
```

‚úî Use it to **share common code** like `openUrl()` across all tests.

---

## ‚úÖ 5. Interface vs Abstract Class ‚Äì Easy Comparison

| Feature                        | Interface                          | Abstract Class                        |
|-------------------------------|-------------------------------------|----------------------------------------|
| Can have method body?         | ‚ùå (Except `default`, `static`)     | ‚úÖ Yes                                  |
| Variables                     | Only `public static final`         | Any type (`private`, `protected`, etc.)|
| Constructors allowed?         | ‚ùå No                               | ‚úÖ Yes                                  |
| Multiple inheritance support  | ‚úÖ Yes                              | ‚ùå No (Only one abstract class allowed) |
| Real-world analogy            | **Job description**                | **Partially built template**           |
| Purpose                       | Enforce structure                  | Share common code + enforce structure  |

---

## ‚úÖ 6. When to Use Interface vs Abstract Class

- **Use Interface** when:
  - You only want to define a structure.
  - You want multiple inheritance.
  - No need to share reusable code.

- **Use Abstract Class** when:
  - You want to **share some code**.
  - You want to enforce some rules + give some help.
  - Inheritance is one-to-one (single parent class).

---

## ‚úÖ 7. Key Takeaways

- Use **Interface** to define "what should be done" in a test (e.g., opening browsers).
- Use **Abstract Class** to provide shared methods like setup, logging, reporting.
- `WebDriver` is an **interface**, allowing flexible browser handling.
- Use **Polymorphism** to switch browsers or implementations easily.


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# üî• OOPs Concepts in Hybrid Automation Framework ‚Äì Study Notes

---

## üîê 1. Encapsulation ‚Äì "Wrap & Protect"

### ‚úÖ Definition:
Encapsulation means bundling data (variables) and methods (functions) into a single unit (class), and restricting direct access to internal details.

### ‚úÖ Why Use It?
- Hides WebElement locators and internal logic
- Protects data from accidental changes
- Improves modularity and safety

### ‚úÖ Where Used?
- Page Object Model classes (LoginPage, HomePage, etc.)

### ‚úÖ When Used?
- When creating page methods that interact with elements

### ‚úÖ Example:
```java
public class LoginPage {
    private WebDriver driver;
    private By email = By.id("email");

    public LoginPage(WebDriver driver) {
        this.driver = driver;
    }

    public void enterEmail(String value) {
        driver.findElement(email).sendKeys(value);
    }
}
```

---

## üß¨ 2. Inheritance ‚Äì "Reusability with Extension"

### ‚úÖ Definition:
Inheritance allows one class to inherit properties and behaviors from another class.

### ‚úÖ Why Use It?
- Reuse browser setup, teardown, config, logging, utilities
- Eliminate code duplication

### ‚úÖ Where Used?
- BaseTest classes, Common Utility classes

### ‚úÖ When Used?
- When writing test classes that need shared setup/logic

### ‚úÖ Example:
```java
public class BaseTest {
    WebDriver driver;

    public void launchBrowser() {
        driver = new ChromeDriver();
    }
}

public class LoginTest extends BaseTest {
    @Test
    public void testLogin() {
        launchBrowser(); // inherited method
    }
}
```

---

## üïµÔ∏è 3. Abstraction ‚Äì "Hide the Details, Show What Matters"

### ‚úÖ Definition:
Abstraction hides complex logic and exposes only relevant methods to the user.

### ‚úÖ Why Use It?
- Keeps tests readable and simple
- Testers don‚Äôt need to know how internal methods work

### ‚úÖ Where Used?
- Page classes, business logic layers, reusable helpers

### ‚úÖ When Used?
- When exposing actions like login, search, checkout, etc.

### ‚úÖ Example:
```java
public class HomePage {
    WebDriver driver;

    public void searchProduct(String product) {
        driver.findElement(By.id("searchBox")).sendKeys(product);
        driver.findElement(By.id("searchBtn")).click();
    }
}
```

---

## üîÑ 4. Polymorphism ‚Äì "One Interface, Many Behaviors"

### ‚úÖ Definition:
Polymorphism means one interface or method behaves differently based on the object.

### ‚úÖ Why Use It?
- Supports cross-browser setup and flexibility
- Allows dynamic object behavior at runtime

### ‚úÖ Where Used?
- WebDriver, Browser interfaces, Data Reader strategy

### ‚úÖ When Used?
- When switching between Chrome, Firefox, Edge
- When building scalable and extensible framework

### ‚úÖ Example:
```java
public interface Browser {
    void openBrowser();
}

public class ChromeBrowser implements Browser {
    public void openBrowser() {
        System.out.println("Chrome Launched");
    }
}

Browser browser = new ChromeBrowser();
browser.openBrowser(); // Output: Chrome Launched
```

---

## üß† Summary Table

| OOP Concept     | Why Use It                                | Where It's Used             | When It's Used                              |
|-----------------|--------------------------------------------|-----------------------------|----------------------------------------------|
| Encapsulation   | Protect internal logic & expose clean API | Page classes (POM)          | When wrapping locators & Selenium actions    |
| Inheritance     | Reuse base methods across tests           | BaseTest, Utility classes   | When writing any test class                  |
| Abstraction     | Hide internal logic from test cases       | Page classes, Helper utils  | When exposing business functions like login  |
| Polymorphism    | Flexible browser/data handling            | Interfaces, DriverFactory   | When enabling cross-browser or strategy use  |
