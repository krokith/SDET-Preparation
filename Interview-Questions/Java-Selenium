1.  Explain me About your Automation Framework ?

I have extensively worked on  a Hybrid Automation Framework for the E-commerce domain using Java, Selenium WebDriver, and Rest Assured. It follows a POM structure with TestNG for execution and Extent/Allure Reports for detailed reporting.
The framework supports UI and API testing, combining data-driven, keyword-driven, and modular approaches.
It‚Äôs integrated with Jenkins CI/CD, so smoke, regression, and API suites run automatically on every build, ensuring quick feedback. 
Overall, it provides end-to-end coverage of e-commerce workflows like product search, checkout, payments, and backend API validations.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2.Explain me the OOPS concepts which u have Used in Framework?

1. Encapsulation ‚Äì "Wrap & Protect"

### ‚úÖ Definition:
Encapsulation means bundling data (variables) and methods (functions) into a single unit (class), and restricting direct access to internal details.
We use encapsulation in POM classes to hide locators and Selenium logic, making the framework safe, modular, and maintainable

### ‚úÖ Why Use It?
- Hides WebElement locators and internal logic
- Protects data from accidental changes
- Improves modularity and safety

### ‚úÖ Where Used?
- Page Object Model classes (LoginPage, HomePage, etc.)

### ‚úÖ When Used?
- When creating page methods that interact with elements
-----------------------------------------------------------------------
## üß¨ 2. Inheritance ‚Äì "Reusability with Extension"
### ‚úÖ Definition:
Inheritance allows one class to inherit properties and behaviors from another class.
### ‚úÖ Why Use It?
- Reuse browser setup, teardown, config, logging, utilities
- Eliminate code duplication

### ‚úÖ Where Used?
- BaseTest classes, Common Utility classes

### ‚úÖ When Used?
- When writing test classes that need shared setup/logic
---------------------------------------------------------------------------------------------------------
## üïµÔ∏è 3. Abstraction ‚Äì "Hide the Details, Show What Matters"
### ‚úÖ Definition:
Abstraction hides complex logic and exposes only relevant methods to the user.
When: When exposing high-level actions like login, search, checkout, or any business flow.
Where: In page classes, helper classes, or business logic layers.
Why:Hides complex Selenium or internal logic from tests
Keeps test scripts simple, readable, and easy to maintain
"We use abstraction to expose only essential actions to tests, hiding the underlying implementation, which makes scripts clean and readable."
exampple
public class LoginPage {
    WebDriver driver;
    public void login(String user, String pass) {
        driver.findElement(By.id("email")).sendKeys(user);
        driver.findElement(By.id("pass")).sendKeys(pass);
        driver.findElement(By.id("loginBtn")).click();
    }
}
// Test
loginPage.login("user@example.com", "password123"); // Hides internal Selenium steps

The login() method abstracts Selenium actions so tests remain clean and readable without knowing the underlying steps."
-------------------------------------------------------------------------------------------------------
## üîÑ 4. Polymorphism ‚Äì "One Interface, Many Behaviors"
### ‚úÖ Definition:
Polymorphism means one interface or method behaves differently based on the object.

In my framework, I use polymorphism to make it flexible and scalable. Method overriding allows the same method to behave differently at runtime
for example, the openBrowser() method behaves differently for Chrome or Firefox objects. Method overloading lets us use the same method name with different parameters,like login(username, password) and login(username, password, otp). 
This way, our framework can handle multiple browsers and login scenarios efficiently without duplicating code."

## üß† Summary Table

| OOP Concept     | Why Use It                                | Where It's Used             | When It's Used                              |
|-----------------|--------------------------------------------|-----------------------------|----------------------------------------------|
| Encapsulation   | Protect internal logic & expose clean API | Page classes (POM)          | When wrapping locators & Selenium actions    |
| Inheritance     | Reuse base methods across tests           | BaseTest, Utility classes   | When writing any test class                  |
| Abstraction     | Hide internal logic from test cases       | Page classes, Helper utils  | When exposing business functions like login  |
| Polymorphism    | Flexible browser/data handling            | Interfaces, DriverFactory   | When enabling cross-browser or strategy use  |

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. How does Selenium Interacts with Browsers

Selenium WebDriver interacts with the browser using a client-server architecture.
First, our test scripts (Java/Python/etc.) send commands to the WebDriver API.
WebDriver communicates with the browser-specific driver (like ChromeDriver, GeckoDriver, EdgeDriver) using the JSON Wire Protocol / W3C WebDriver protocol
The driver translates these commands into native browser actions (like click, type, navigate).
The browser executes them and sends the response back to WebDriver, which our test script can use.

Example: When we call driver.findElement(), the flow is:
Test Script ‚Üí WebDriver API ‚Üí Browser Driver ‚Üí Browser ‚Üí Response ‚Üí Back to Script.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4.Explain Java Collections and where do we use it in our Automation Framework?

The Java Collections Framework (in java.util) is a set of interfaces and classes (e.g., List, Set, Map) for storing and manipulating groups of objects. 
It provides reusable data structures like ArrayList, HashSet, and HashMap with methods for adding, removing, and processing data efficiently.

List (ArrayList): Ordered, allows duplicates (e.g., web elements).
Set (HashSet): Unique items (e.g., error messages).
Map (HashMap): Key-value pairs (e.g., test data).
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. ArrayList vs LinkedList
ArrayList
Data Structure: Uses a dynamic array internally.
Access Time: O(1) for random access (fast lookups by index).
Insert/Delete: O(n) in worst case (shifting required when inserting/removing in the middle).
Best Use Case: When you need frequent access/iteration and fewer insertions/deletions.

LinkedList
Data Structure: Uses a doubly linked list internally.
Access Time: O(n) for random access (must traverse nodes).
Insert/Delete: O(1) if node reference is known (no shifting required).
Best Use Case: When you need frequent insertions/deletions, especially in the middle.

"ArrayList is better for fast random access, while LinkedList is better for frequent insertions and deletions."
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6.  What is PageObjectModel?

POM is one of a Design Pattern where Web UI elements and actions are stored as a methods in separate page classes
We use POM structure in Automation Framewotk to separate the each page classes and UI locators
which Increases readability, reusability, and maintainability. If a locator changes, we only update in one place.

Example:  instead of writing locators directly in test cases we write in a class with a method and call them as LoginPage.login(username, password).

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7. what are Design pattern
Design Patterns in Automation Framework
Design patterns are proven solutions to common problems in framework design. In automation, they help improve reusability, maintainability, and scalability. Some commonly used patterns are:

Page Object Model (POM)
Separates UI locators and test logic into different classes.
Reduces duplication, makes scripts maintainable.
Example: LoginPage.login(username, password) instead of writing locators directly in test cases.

Singleton Pattern
Ensures only one WebDriver instance is created across tests.
Prevents multiple browser sessions from conflicting.

Factory Pattern
Used for object creation.
Example: A DriverFactory class that returns different browsers (Chrome, Firefox) based on config.

Data-Driven / Strategy Pattern
Allows running the same test with different sets of data (Excel, JSON, DB, CSV).
Improves test coverage without duplicating code.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
8.  Waits in Selenium 
In automation frameworks, waits are used to handle synchronization. We mainly use implicit waits (global), explicit waits (condition-based), and fluent waits (with polling).

Implicit Wait
Global wait applied to the entire WebDriver instance.
Tells WebDriver to wait for a fixed amount of time while locating elements before throwing NoSuchElementException.
Example: driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
Explicit Wait
Waits for a specific condition to be met before proceeding.
More powerful and flexible than implicit wait.
Fluent wait 
A type of explicit wait with polling frequency and ability to ignore exceptions.

Hard waits like Thread.sleep() are less efficient and should be avoided unless absolutely necessary
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9.  Abstract class vs Inheritance 
Abstract Class
A class declared with the keyword abstract.
Can have both abstract methods (no body) and concrete methods (with implementation).
Cannot be instantiated directly; must be inherited by a subclass.
Support Single inheritance
u can use abstract class when u need base implementation
Example:

abstract class Animal {
    abstract void sound();  // abstract method
    void sleep() {          // concrete method
        System.out.println("Sleeping");
    }
}

Inheritance
A contract that defines a Set of abstract methods which a class has to implement in it 
its a Blueprint 
Support multiple inheritance
Access modifier are public
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

10. what are Constrcutors?
A special method in Java that is called automatically when an object is created.
Purpose ‚Üí To initialize objects (assign values, setup dependencies).
Constructor name = Class name, and it has no return type.
Types - Default, paramter and copy 
 We use In Automation Frameworks (POM) ‚Üí Used to initialize WebDriver, PageFactory, and other utilities when a Page class is created.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

11.  Errors and Exceptions 
Errors: errors are some issues which occur at runtime and cannot be Handled in code 
example: Out of Memory error/StackOverflow error - happens due to system failures
Exceptions : some unexpected events which distrubs the flow of execution, which can be handled and caught by using try and catch block

Types 
Checked Exceptions(Compile time) -  must be handled try catch and throws - eg: IO exceptions,SQL Exceptions
Unchecked Exceptions(Runtime) -  Occurs at Runtime only - eg : Nullpointer Exception,ArrayIndexOut of Bond
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

12. Exception Handling
The Exception Handling make sures that the Current Test Script doent abrutly fail due to some unwanted flow of events
so we use try catch finally block or throws to Handle the exceptions 

i) How do you design a custom exception for a test framework?
Custom exceptions make error messages more meaningful in automation frameworks. 
Custom exceptions give more context-specific errors rather than generic ones. For example, in a Selenium framework, 
if an element is not found, instead of throwing a generic NoSuchElementException, we can define a custom exception like:
we can predefine the exceptiion method and give meaning message while calling it 
for eg: class ElementNotFoundException extends Exception {
    public ElementNotFoundException(String message) {
        super(message);
    }
}

// Usage in framework
if(element == null) {
   throw new ElementNotFoundException("Login button not found on page");
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
13. Method Overloading and Overriding 

i)method Overloading happens when same method used mulitple times with the same name but different parameters within class
it is resiolved in compile time so called as compile time polymorphism
Allows a class to perform a diff ways to actions
doent support inheritance

ii) Overriding happens when the subclass provides specific way of its own implementattions which has inherited by the Superclass
Supports inheritance
its resolved in runtime polymorphism
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
14. what is Garbage collector ?

Garbage collector  in java is mainly used to automatically manage the memory which has been occupied by Object class
it removes the unused objects from memory to free up the resources
we can call system.gc to cleanup the unused memories

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
15. What is static ?
The static keyword in Java is mainly used for memory management. It can be applied to variables, methods, blocks, and nested classes
 Anything declared static belongs to the class rather than to a specific object, which means it is shared across all instances.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

16.  What is Object class?
Object is the parent class of all classes in Java.
Every class implicitly inherits from Object.
It provides common methods like toString(), equals(), hashCode(), clone(), etc.
 Example: Even if you don‚Äôt extend anything, your class still extends Object.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
17.Difference between final, finally, and finalize

final ‚Üí Keyword used with variables (constant), methods (cannot override), and classes (cannot extend).
finally ‚Üí Block in try-catch used to execute cleanup code (always runs).
finalize() ‚Üí Method called by Garbage Collector before destroying an object.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
18.what is maven with commands?
Maven is a Build Automation and depedency management Tool
which has JAR files,plugIns, CI/CD integrations and helps to run the Test easily 
we use Maven to simplify the project Setup and manage the dependencies

Commands 
mvn clean -> remove the previous Build and clean it 
mvn compile -> compile the source code
mvn test -> runs the Current Testcase 
mvn install -> install the package into local repo
mvn package -> packages the code into JAR
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
19. what are Strings StringBuilder and StringBuffer?

Difference between String, StringBuffer, and StringBuilder
String ‚Üí Immutable; once created, value cannot change. Every modification creates a new object.
StringBuffer ‚Üí Mutable and thread-safe, but slower due to synchronization.
StringBuilder ‚Üí Mutable and faster, but not thread-safe.
Use String for constants, StringBuilder for fast modifications, and StringBuffer in multi-threaded contexts.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

20. Difference between JDK, JRE, JVM

JVM is the Java Virtual Machine that executes Java bytecode and makes Java platform-independent.
JRE is the Java Runtime Environment, which provides JVM plus libraries and files needed to run Java applications.
JDK is the Java Development Kit, which includes JRE plus compilers and tools needed to develop Java programs.
üëâ In short: JVM runs, JRE supports, JDK develops.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
21.Difference between List, Set, and Map

List ‚Üí Ordered collection, allows duplicates, indexed access. Example: ArrayList for storing test inputs.
Set ‚Üí Unordered collection, no duplicates. Example: HashSet for unique locators or IDs.
Map ‚Üí Stores key-value pairs, keys unique. Example: HashMap for storing element locators with their names.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
22. How will u handle Flaky test ?
A flaky test is one that shows inconsistent results ‚Äì it passes sometimes and fails other times without any code changes.
They often occur due to timing issues, unstable environments, or test data dependencies. To handle them, I use explicit waits instead of hard waits, isolate tests to remove dependencies,
ensure stable test data, and if needed, add retry logic in CI. Proper logging also helps in diagnosing and fixing flaky behavior.‚Äù
