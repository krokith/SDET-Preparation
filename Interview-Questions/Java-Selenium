1.  Explain me About your Automation Framework ?

I have extensively worked on  a Hybrid Automation Framework for the E-commerce domain using Java, Selenium WebDriver, and Rest Assured. It follows a POM structure with TestNG for execution and Extent/Allure Reports for detailed reporting.
The framework supports UI and API testing, combining data-driven, keyword-driven, and modular approaches.
It‚Äôs integrated with Jenkins CI/CD, so smoke, regression, and API suites run automatically on every build, ensuring quick feedback. 
Overall, it provides end-to-end coverage of e-commerce workflows like product search, checkout, payments, and backend API validations.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2.Explain me the OOPS concepts which u have Used in Framework?

1. Encapsulation ‚Äì "Wrap & Protect"

### ‚úÖ Definition:
Encapsulation means bundling data (variables) and methods (functions) into a single unit (class), and restricting direct access to internal details.
We use encapsulation in POM classes to hide locators and Selenium logic, making the framework safe, modular, and maintainable

### ‚úÖ Why Use It?
- Hides WebElement locators and internal logic
- Protects data from accidental changes
- Improves modularity and safety

### ‚úÖ Where Used?
- Page Object Model classes (LoginPage, HomePage, etc.)

### ‚úÖ When Used?
- When creating page methods that interact with elements
-----------------------------------------------------------------------
## üß¨ 2. Inheritance ‚Äì "Reusability with Extension"
### ‚úÖ Definition:
Inheritance allows one class to inherit properties and behaviors from another class.
### ‚úÖ Why Use It?
- Reuse browser setup, teardown, config, logging, utilities
- Eliminate code duplication

### ‚úÖ Where Used?
- BaseTest classes, Common Utility classes

### ‚úÖ When Used?
- When writing test classes that need shared setup/logic
---------------------------------------------------------------------------------------------------------
## üïµÔ∏è 3. Abstraction ‚Äì "Hide the Details, Show What Matters"
### ‚úÖ Definition:
Abstraction hides complex logic and exposes only relevant methods to the user.
When: When exposing high-level actions like login, search, checkout, or any business flow.
Where: In page classes, helper classes, or business logic layers.
Why:Hides complex Selenium or internal logic from tests
Keeps test scripts simple, readable, and easy to maintain
"We use abstraction to expose only essential actions to tests, hiding the underlying implementation, which makes scripts clean and readable."
exampple
public class LoginPage {
    WebDriver driver;
    public void login(String user, String pass) {
        driver.findElement(By.id("email")).sendKeys(user);
        driver.findElement(By.id("pass")).sendKeys(pass);
        driver.findElement(By.id("loginBtn")).click();
    }
}
// Test
loginPage.login("user@example.com", "password123"); // Hides internal Selenium steps

The login() method abstracts Selenium actions so tests remain clean and readable without knowing the underlying steps."
-------------------------------------------------------------------------------------------------------
## üîÑ 4. Polymorphism ‚Äì "One Interface, Many Behaviors"
### ‚úÖ Definition:
Polymorphism means one interface or method behaves differently based on the object.

In my framework, I use polymorphism to make it flexible and scalable. Method overriding allows the same method to behave differently at runtime
for example, the openBrowser() method behaves differently for Chrome or Firefox objects. Method overloading lets us use the same method name with different parameters,like login(username, password) and login(username, password, otp). 
This way, our framework can handle multiple browsers and login scenarios efficiently without duplicating code."

## üß† Summary Table

| OOP Concept     | Why Use It                                | Where It's Used             | When It's Used                              |
|-----------------|--------------------------------------------|-----------------------------|----------------------------------------------|
| Encapsulation   | Protect internal logic & expose clean API | Page classes (POM)          | When wrapping locators & Selenium actions    |
| Inheritance     | Reuse base methods across tests           | BaseTest, Utility classes   | When writing any test class                  |
| Abstraction     | Hide internal logic from test cases       | Page classes, Helper utils  | When exposing business functions like login  |
| Polymorphism    | Flexible browser/data handling            | Interfaces, DriverFactory   | When enabling cross-browser or strategy use  |

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. How does Selenium Interacts with Browsers

Selenium WebDriver interacts with the browser using a client-server architecture.
First, our test scripts (Java/Python/etc.) send commands to the WebDriver API.
WebDriver communicates with the browser-specific driver (like ChromeDriver, GeckoDriver, EdgeDriver) using the JSON Wire Protocol / W3C WebDriver protocol
The driver translates these commands into native browser actions (like click, type, navigate).
The browser executes them and sends the response back to WebDriver, which our test script can use.

Example: When we call driver.findElement(), the flow is:
Test Script ‚Üí WebDriver API ‚Üí Browser Driver ‚Üí Browser ‚Üí Response ‚Üí Back to Script.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4.Explain Java Collections and where do we use it in our Automation Framework?

The Java Collections Framework (in java.util) is a set of interfaces and classes (e.g., List, Set, Map) for storing and manipulating groups of objects. 
It provides reusable data structures like ArrayList, HashSet, and HashMap with methods for adding, removing, and processing data efficiently.

List (ArrayList): Ordered, allows duplicates (e.g., web elements).
Set (HashSet): Unique items (e.g., error messages).
Map (HashMap): Key-value pairs (e.g., test data).
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5.ArrayList

Resizable array implementation.
Fast random access (O(1) by index).
Slow insert/delete in middle (O(n) due to shifting).
Less memory overhead.
Best when you need more reads/iterations, fewer modifications.

LinkedList
Doubly linked list implementation.
Slow random access (O(n) traversal).
Fast insert/delete (O(1) if node reference is known, no shifting).
More memory (stores data + pointers).
Best when you need frequent insertions/deletions.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6.  What is PageObjectModel?

POM is one of a Design Pattern where Web UI elements and actions are stored as a methods in separate page classes
We use POM structure in Automation Framewotk to separate the each page classes and UI locators
which Increases readability, reusability, and maintainability. If a locator changes, we only update in one place.

Example:  instead of writing locators directly in test cases we write in a class with a method and call them as LoginPage.login(username, password).

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7. what are Design pattern
Design Patterns in Automation Framework
Design patterns are proven solutions to common problems in framework design. In automation, they help improve reusability, maintainability, and scalability. Some commonly used patterns are:

Page Object Model (POM)
Separates UI locators and test logic into different classes.
Reduces duplication, makes scripts maintainable.
Example: LoginPage.login(username, password) instead of writing locators directly in test cases.

Singleton Pattern
Ensures only one WebDriver instance is created across tests.
Prevents multiple browser sessions from conflicting.

Factory Pattern
Used for object creation.
Example: A DriverFactory class that returns different browsers (Chrome, Firefox) based on config.

Data-Driven / Strategy Pattern
Allows running the same test with different sets of data (Excel, JSON, DB, CSV).
Improves test coverage without duplicating code.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
8.  Waits in Selenium 
In automation frameworks, waits are used to handle synchronization. We mainly use implicit waits (global), explicit waits (condition-based), and fluent waits (with polling).

Implicit Wait
Global wait applied to the entire WebDriver instance.
Tells WebDriver to wait for a fixed amount of time while locating elements before throwing NoSuchElementException.
Example: driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
Explicit Wait
Waits for a specific condition to be met before proceeding.
More powerful and flexible than implicit wait.
Fluent wait 
A type of explicit wait with polling frequency and ability to ignore exceptions.

Hard waits like Thread.sleep() are less efficient and should be avoided unless absolutely necessary

ii) Hard wait (Thread.sleep) pauses execution for a fixed time, always waits, and is not recommended.
Implicit wait sets a global polling time, where WebDriver waits up to that time for elements to appear, moving on as soon as they‚Äôre found. 
We use implicit waits for general synchronization and avoid hard waits except in rare debugging cases.
All three Waits - definitions
we have different types of waits. Hard wait (Thread.sleep) simply pauses for a fixed time, but it‚Äôs not recommended since it always waits even if not needed. 
Implicit wait is set once at the start and acts as a global timeout for finding elements. Explicit wait is more powerful‚Äîit waits for specific conditions like visibility or clickability of an element.
Fluent wait is an advanced form of explicit wait where we can define polling frequency and exceptions to ignore. 
In practice, we usually set a small implicit wait globally and use explicit or fluent waits for handling dynamic elements
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9.  Abstract class vs interface 
Abstract Class
A class declared with the keyword abstract.
Can have both abstract methods (no body) and concrete methods (with implementation).
Cannot be instantiated directly; must be inherited by a subclass.
Support Single inheritance
u can use abstract class when u need base implementation
Example:

abstract class Animal {
    abstract void sound();  // abstract method
    void sleep() {          // concrete method
        System.out.println("Sleeping");
    }
}

interface
A contract that defines a Set of abstract methods which a class has to implement in it 
its a Blueprint 
Support multiple inheritance
Access modifier are public 

even Webdriver is a Interface because it has lots of predefined browser actions where we could use it instantly
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

10. what are Constrcutors?
A special method in Java that is called automatically when an object is created.
Purpose ‚Üí To initialize objects (assign values, setup dependencies).
Constructor name = Class name, and it has no return type.
Types - Default, paramter and copy 
 We use In Automation Frameworks (POM) ‚Üí Used to initialize WebDriver, PageFactory, and other utilities when a Page class is created.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

11.  Errors and Exceptions 
Errors: errors are some issues which occur at runtime and cannot be Handled in code 
example: Out of Memory error/StackOverflow error - happens due to system failures
Exceptions : some unexpected events which distrubs the flow of execution, which can be handled and caught by using try and catch block

Types 
Checked Exceptions(Compile time) -  must be handled try catch and throws - eg: IO exceptions,SQL Exceptions
Unchecked Exceptions(Runtime) -  Occurs at Runtime only - eg : Nullpointer Exception,ArrayIndexOut of Bond

Checked exceptions are forced by compiler because they deal with external resources, e.g., file, DB, network. 
Unchecked exceptions happen at runtime due to code errors, e.g., null pointers or invalid array access.‚Äù

‚ÄúWe handle checked exceptions with try-catch or throws, but unchecked exceptions are usually fixed in the code.‚Äù
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

12. Exception Handling
The Exception Handling make sures that the Current Test Script doesn't abrutly fail due to some unwanted flow of events
so we use try catch finally block or throws to Handle the exceptions 

i) How do you design a custom exception for a test framework?
Custom exceptions make error messages more meaningful in automation frameworks. 
Custom exceptions give more context-specific errors rather than generic ones. For example, in a Selenium framework, 
if an element is not found, instead of throwing a generic NoSuchElementException, we can define a custom exception like:
we can predefine the exceptiion method and give meaning message while calling it 
for eg: class ElementNotFoundException extends Exception {
    public ElementNotFoundException(String message) {
        super(message);
    }
}

// Usage in framework
if(element == null) {
   throw new ElementNotFoundException("Login button not found on page");
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
13. Method Overloading and Overriding 

i)method Overloading happens when same method used mulitple times with the same name but different parameters within class
it is resiolved in compile time so called as compile time polymorphism
Allows a class to perform a diff ways to actions
doent support inheritance

ii) Overriding happens when the subclass provides specific way of its own implementattions which has inherited by the Superclass
Supports inheritance
its resolved in runtime polymorphism
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
14. what is Garbage collector ?

Garbage collector  in java is mainly used to automatically manage the memory which has been occupied by Object class
it removes the unused objects from memory to free up the resources
we can call system.gc to cleanup the unused memories

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
15. What is static ?
The static keyword in Java is mainly used for memory management. It can be applied to variables, methods, blocks, and nested classes
 Anything declared static belongs to the class rather than to a specific object, which means it is shared across all instances.
Static variables ‚Üí There is only one shared copy for the entire class.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

16.  What is Object class?
Object is the parent class of all classes in Java.
Every class implicitly inherits from Object.
It provides common methods like toString(), equals(), hashCode(), clone(), etc.
 Example: Even if you don‚Äôt extend anything, your class still extends Object.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
17.Difference between final, finally, and finalize

final ‚Üí Keyword used with variables (constant), methods (cannot override), and classes (cannot extend).
finally ‚Üí Block in try-catch used to execute cleanup code (always runs).
finalize() ‚Üí Method called by Garbage Collector before destroying an object.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
18.what is maven with commands?
Maven is a Build Automation and depedency management Tool
which has JAR files,plugIns, CI/CD integrations and helps to run the Test easily 
we use Maven to simplify the project Setup and manage the dependencies

Commands 
mvn clean -> remove the previous Build and clean it 
mvn compile -> compile the source code
mvn test -> runs the Current Testcase 
mvn install -> install the package into local repo
mvn package -> packages the code into JAR
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
19. what are Strings StringBuilder and StringBuffer?

Difference between String, StringBuffer, and StringBuilder
String ‚Üí Immutable; once created, value cannot change. Every modification creates a new object.
StringBuffer ‚Üí Mutable and thread-safe, but slower due to synchronization.
StringBuilder ‚Üí Mutable and faster, but not thread-safe.
Use String for constants, StringBuilder for fast modifications, and StringBuffer in multi-threaded contexts.

Strings are immutable and stored in the string pool for security, memory efficiency, and thread safety. 
StringBuilder is mutable and fast (heap only), while StringBuffer is mutable and thread-safe for multi-threaded operations
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

20. Difference between JDK, JRE, JVM

JVM is the Java Virtual Machine that executes Java bytecode and makes Java platform-independent.
JRE is the Java Runtime Environment, which provides JVM plus libraries and files needed to run Java applications.
JDK is the Java Development Kit, which includes JRE plus compilers and tools needed to develop Java programs.
üëâ In short: JVM runs, JRE supports, JDK develops.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
21.Difference between List, Set, and Map

List ‚Üí Ordered collection, allows duplicates, indexed access. Example: ArrayList for storing test inputs.
Set ‚Üí Unordered collection, no duplicates. Example: HashSet for unique locators or IDs.
Map ‚Üí Stores key-value pairs, keys unique. Example: HashMap for storing element locators with their names.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
22. How will u handle Flaky test ?
A flaky test is one that shows inconsistent results ‚Äì it passes sometimes and fails other times without any code changes.
They often occur due to timing issues, unstable environments, or test data dependencies. To handle them, I use explicit waits instead of hard waits, isolate tests to remove dependencies,
ensure stable test data, and if needed, add retry logic in CI. Proper logging also helps in diagnosing and fixing flaky behavior.‚Äù
------------------------------------------------------------------------------------------------------------------------------------------------------
23. Typecasting
Typecasting is converting one data type to another. In test automation, I often use it when working with API responses, Excel data, or Selenium UI values. 
For example, an API might return a value as 12.0 (double), but my validation expects an integer 12, so I cast it. Similarly, while validating product prices in e-commerce UI, 
I might get ‚Çπ199.99 as a string, convert it to double, and then cast to int for comparison This helps align actual values with expected values in test cases

For eg : String numericPart = priceStr.replace("‚Çπ", "").trim();
        // Step 3: Convert to double
        double priceDouble = Double.parseDouble(numericPart)
        // Step 4: Cast to int
        int priceInt = (int) priceDouble;
------------------------------------------------------------------------------------------------------------------------------------------------------
24. why javaScript is better than Java-Selenium?
JavaScript-based automation frameworks (like Cypress or Playwright) are preferred for modern web apps because they are faster, handle dynamic content better,
have built-in waits, simpler setup, and provide integrated reporting.
Java-Selenium is powerful, but JS frameworks reduce flakiness and speed up development for front-end testing.
------------------------------------------------------------------------------------------------------------------------------------------------------
25. Abstract Classes

Definition: Class with abstract methods (no body) + concrete methods (with body).

Why use:

Reuse common code (setup/teardown)
Force child classes to implement required methods
Maintain framework consistency
Example: BaseTest with setup(), tearDown(), and abstract runTest().
Key: Child class implements abstract methods, can directly use concrete methods.
Interview Tip:
‚ÄúAbstract classes allow partial implementation + enforce structure, unlike normal base classes where all methods are implemented.‚Äù

3. Inheritance in Java

Types: Single, Multilevel, Hierarchical.
Multiple inheritance with classes ‚Üí not allowed.
Multiple interfaces ‚Üí allowed.
Example in Selenium:
class Test extends BaseTest implements ITestListener, IDriverFactory {}
Why: Combine setup/teardown (BaseTest) + listeners + driver creation without diamond problem.

4. Interfaces

Purpose: Define a contract (methods without body) that must be implemented.
Usage in Selenium:
Listeners: React to test events (onTestStart, onTestFailure).
Factories: Provide WebDriver objects dynamically.
Benefit: Allows multiple behaviors without multiple class inheritance.

5. Selenium Components

Selenium IDE ‚Üí Record & playback tool
Selenium RC ‚Üí Older, now deprecated
Selenium WebDriver ‚Üí Modern API for browser control
Selenium Grid ‚Üí Parallel/distributed test execution
---------------------------------------------------------------------------------------------------------------------------------

27. Wrapper Class

Definition: Classes that wrap primitive data types (int, boolean, etc.) into objects.
Every primitive type has a corresponding wrapper class:
Uses 
Wrapper classes allow us to parse Strings to numbers and store primitive values in collections like ArrayList or HashMap,
because collections require objects, not primitives

----------------------------------------------------------------------------------------------------------------------------------
28. 1Ô∏è‚É£ Access Modifiers
Modifier	Access Level
public	Accessible everywhere
private	Accessible only within the class
protected	Accessible in same package + subclasses
default/no modifier	Accessible in same package only
Tip: Use private for variables ‚Üí provide getter/setter. Use protected for inheritance scenarios.

2Ô∏è‚É£ this Keyword
Refers to current object
Differentiates instance & local variables
Can call another constructor
Example:

public class Demo {
    int id;
    Demo(int id) {
        this.id = id; // assigns local id to instance variable
    }
}

3Ô∏è‚É£ super Keyword
Refers to parent class object
Used to call parent constructor or parent method

5Ô∏è‚É£ String Pool & intern()

String Pool: Memory for reusing string literals
String s1 = "Hello"; // pool
String s2 = "Hello"; // same object

new String() ‚Üí creates new heap object
intern() ‚Üí returns string from pool
Example:
String s3 = new String("Hello").intern(); // pool reference

Tip: Strings are immutable, using pool saves memory & ensures reuse.

-----------------------------------------------------------------------------------------------------------------------------------------
29. Java Collections 

Purpose: Store, manage, and manipulate groups of objects efficiently
List ‚Üí ordered, duplicates, indexed
Set ‚Üí unique, unordered
Map ‚Üí key-value, unique keys
ArrayList vs LinkedList ‚Üí fast read vs fast insert/delete
HashMap/TreeMap ‚Üí unordered vs sorted
Generics ‚Üí type safety, no casting
-----------------------------------------------------------------------------------------------------------------------------------------
30. 
Black Box Testing üéØ
Tester doesn‚Äôt see the code.
Focus: functional behavior (inputs ‚Üí outputs).
Example: Selenium UI tests, API tests.
White Box Testing üéØ
Tester knows the internal code/logic.
Focus: code paths, conditions, loops.
Example: Unit tests, code coverage, JUnit/TestNG tests.
Gray Box Testing üéØ
Partial knowledge of code.
Combines black & white box.
Example: API tests with knowledge of database structure.

üëâ In automation:
UI automation ‚Üí Black Box
Unit test frameworks ‚Üí White Box
Integration/service tests ‚Üí Gray Box
-----------------------------------------------------------------------------------------------------------------------------------------
31. what is Unit test

A Unit Test is a type of software test that verifies the correctness of a smallest independent piece of code (usually a method, function, or class) in isolation from the rest of the system.
It checks whether that unit produces the expected output for given inputs.
It is usually written and run by developers.
It is considered White Box Testing.

Goal ‚Üí Catch bugs early, ensure code reliability, and make refactoring safe.
üëâ Example: Testing if a method add(2,3) correctly returns 5.
In a real automation framework, unit tests focus on small building blocks (utilities, parsers, helpers, custom wait methods, data readers, API wrappers).
This makes the framework reliable before plugging it into bigger E2E Selenium/Appium test cases.

-----------------------------------------------------------------------------------------------------------------------------------------
32.  Assertions and its type 

Hard vs Soft Assertions (Selenium/TestNG)
Hard Assertion ‚úÖ
Stops test execution immediately on failure.
Use for critical checks (page title, essential elements).

Example:
assertEquals(driver.getTitle(), "Home Page");
assertTrue(element.isDisplayed());
assertNotNull(element);
fail("Critical element missing!");

Soft Assertion ‚úÖ

Continues test execution even if assertion fails; reports all failures at the end.
Use for multiple UI validations in one test.
Example:

SoftAssert soft = new SoftAssert();
soft.assertEquals(driver.getTitle(), "Home Page");
soft.assertTrue(element.isDisplayed());
soft.assertNotNull(element);
soft.fail("Critical element missing!");
soft.assertAll(); // marks test as failed if any soft assertion failed
Key Tip:
Hard ‚Üí stop immediately
Soft ‚Üí continue and report all
-----------------------------------------------------------------------------------------------------------------------------------------
33. Functional Testing

What it is: Tests features & business requirements ‚Üí ‚ÄúDoes it work?‚Äù
Focus: Functionality, workflows, API responses, user actions
Example: Login works, search returns correct results
Type: Usually black-box testing

Non-Functional Testing
What it is: Tests performance & quality attributes ‚Üí ‚ÄúHow well does it work?‚Äù
Focus: Speed, scalability, security, usability, reliability
Example: Page loads in <2s, app supports 1000 users, secure login
Type: Performance, Load, Stress, Security, Usability testing

üí° Memory Tip:
Functional = Features
Non-Functional = Quality
-----------------------------------------------------------------------------------------------------------------------------------------
34. 
Performance Testing in JUnit (Summary)
Purpose: Check if a method or code executes within an expected time.
Tools in JUnit:
assertTimeout(Duration, Executable) ‚Üí Fails if code exceeds max allowed time.
System.currentTimeMillis() ‚Üí Measure execution time manually and assert threshold.
Use Case: Quick unit-level performance checks (method execution, page load time).

Limitation: Not for large-scale load/stress testing ‚Üí Use JMeter, Gatling, or Locust for that.
üí° Memory Tip:
JUnit = Unit-level performance check
Load/Stress = Dedicated tools
-----------------------------------------------------------------------------------------------------------------------------------------
35. 

